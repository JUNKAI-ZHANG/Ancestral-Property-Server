// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Room.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Room_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Room_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Room_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Room_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Room_2eproto;
namespace RoomProto {
class CreateRoom;
struct CreateRoomDefaultTypeInternal;
extern CreateRoomDefaultTypeInternal _CreateRoom_default_instance_;
class GetRoomList;
struct GetRoomListDefaultTypeInternal;
extern GetRoomListDefaultTypeInternal _GetRoomList_default_instance_;
class GetUserList;
struct GetUserListDefaultTypeInternal;
extern GetUserListDefaultTypeInternal _GetUserList_default_instance_;
class JoinGame;
struct JoinGameDefaultTypeInternal;
extern JoinGameDefaultTypeInternal _JoinGame_default_instance_;
class JoinRoom;
struct JoinRoomDefaultTypeInternal;
extern JoinRoomDefaultTypeInternal _JoinRoom_default_instance_;
class LeaveRoom;
struct LeaveRoomDefaultTypeInternal;
extern LeaveRoomDefaultTypeInternal _LeaveRoom_default_instance_;
class QuitGame;
struct QuitGameDefaultTypeInternal;
extern QuitGameDefaultTypeInternal _QuitGame_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RoomStatusChangeRequest;
struct RoomStatusChangeRequestDefaultTypeInternal;
extern RoomStatusChangeRequestDefaultTypeInternal _RoomStatusChangeRequest_default_instance_;
class RoomStatusChangeResponse;
struct RoomStatusChangeResponseDefaultTypeInternal;
extern RoomStatusChangeResponseDefaultTypeInternal _RoomStatusChangeResponse_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace RoomProto
PROTOBUF_NAMESPACE_OPEN
template<> ::RoomProto::CreateRoom* Arena::CreateMaybeMessage<::RoomProto::CreateRoom>(Arena*);
template<> ::RoomProto::GetRoomList* Arena::CreateMaybeMessage<::RoomProto::GetRoomList>(Arena*);
template<> ::RoomProto::GetUserList* Arena::CreateMaybeMessage<::RoomProto::GetUserList>(Arena*);
template<> ::RoomProto::JoinGame* Arena::CreateMaybeMessage<::RoomProto::JoinGame>(Arena*);
template<> ::RoomProto::JoinRoom* Arena::CreateMaybeMessage<::RoomProto::JoinRoom>(Arena*);
template<> ::RoomProto::LeaveRoom* Arena::CreateMaybeMessage<::RoomProto::LeaveRoom>(Arena*);
template<> ::RoomProto::QuitGame* Arena::CreateMaybeMessage<::RoomProto::QuitGame>(Arena*);
template<> ::RoomProto::RoomInfo* Arena::CreateMaybeMessage<::RoomProto::RoomInfo>(Arena*);
template<> ::RoomProto::RoomStatusChangeRequest* Arena::CreateMaybeMessage<::RoomProto::RoomStatusChangeRequest>(Arena*);
template<> ::RoomProto::RoomStatusChangeResponse* Arena::CreateMaybeMessage<::RoomProto::RoomStatusChangeResponse>(Arena*);
template<> ::RoomProto::UserInfo* Arena::CreateMaybeMessage<::RoomProto::UserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RoomProto {

enum JoinRoom_Type : int {
  JoinRoom_Type_REQUEST = 0,
  JoinRoom_Type_RESPONSE = 1,
  JoinRoom_Type_JoinRoom_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JoinRoom_Type_JoinRoom_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JoinRoom_Type_IsValid(int value);
constexpr JoinRoom_Type JoinRoom_Type_Type_MIN = JoinRoom_Type_REQUEST;
constexpr JoinRoom_Type JoinRoom_Type_Type_MAX = JoinRoom_Type_RESPONSE;
constexpr int JoinRoom_Type_Type_ARRAYSIZE = JoinRoom_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JoinRoom_Type_descriptor();
template<typename T>
inline const std::string& JoinRoom_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinRoom_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinRoom_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JoinRoom_Type_descriptor(), enum_t_value);
}
inline bool JoinRoom_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinRoom_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JoinRoom_Type>(
    JoinRoom_Type_descriptor(), name, value);
}
enum LeaveRoom_Type : int {
  LeaveRoom_Type_REQUEST = 0,
  LeaveRoom_Type_RESPONSE = 1,
  LeaveRoom_Type_LeaveRoom_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LeaveRoom_Type_LeaveRoom_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LeaveRoom_Type_IsValid(int value);
constexpr LeaveRoom_Type LeaveRoom_Type_Type_MIN = LeaveRoom_Type_REQUEST;
constexpr LeaveRoom_Type LeaveRoom_Type_Type_MAX = LeaveRoom_Type_RESPONSE;
constexpr int LeaveRoom_Type_Type_ARRAYSIZE = LeaveRoom_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaveRoom_Type_descriptor();
template<typename T>
inline const std::string& LeaveRoom_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaveRoom_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaveRoom_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaveRoom_Type_descriptor(), enum_t_value);
}
inline bool LeaveRoom_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaveRoom_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaveRoom_Type>(
    LeaveRoom_Type_descriptor(), name, value);
}
enum CreateRoom_Type : int {
  CreateRoom_Type_REQUEST = 0,
  CreateRoom_Type_RESPONSE = 1,
  CreateRoom_Type_CreateRoom_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CreateRoom_Type_CreateRoom_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CreateRoom_Type_IsValid(int value);
constexpr CreateRoom_Type CreateRoom_Type_Type_MIN = CreateRoom_Type_REQUEST;
constexpr CreateRoom_Type CreateRoom_Type_Type_MAX = CreateRoom_Type_RESPONSE;
constexpr int CreateRoom_Type_Type_ARRAYSIZE = CreateRoom_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreateRoom_Type_descriptor();
template<typename T>
inline const std::string& CreateRoom_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateRoom_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateRoom_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreateRoom_Type_descriptor(), enum_t_value);
}
inline bool CreateRoom_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreateRoom_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreateRoom_Type>(
    CreateRoom_Type_descriptor(), name, value);
}
enum GetRoomList_Type : int {
  GetRoomList_Type_REQUEST = 0,
  GetRoomList_Type_RESPONSE = 1,
  GetRoomList_Type_GetRoomList_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetRoomList_Type_GetRoomList_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetRoomList_Type_IsValid(int value);
constexpr GetRoomList_Type GetRoomList_Type_Type_MIN = GetRoomList_Type_REQUEST;
constexpr GetRoomList_Type GetRoomList_Type_Type_MAX = GetRoomList_Type_RESPONSE;
constexpr int GetRoomList_Type_Type_ARRAYSIZE = GetRoomList_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetRoomList_Type_descriptor();
template<typename T>
inline const std::string& GetRoomList_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetRoomList_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetRoomList_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetRoomList_Type_descriptor(), enum_t_value);
}
inline bool GetRoomList_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetRoomList_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetRoomList_Type>(
    GetRoomList_Type_descriptor(), name, value);
}
// ===================================================================

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit constexpr UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kUseridFieldNumber = 2,
    kIsRoomHostFieldNumber = 3,
    kRoleIdFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // int32 userid = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // bool is_roomHost = 3;
  void clear_is_roomhost();
  bool is_roomhost() const;
  void set_is_roomhost(bool value);
  private:
  bool _internal_is_roomhost() const;
  void _internal_set_is_roomhost(bool value);
  public:

  // int32 role_id = 4;
  void clear_role_id();
  int32_t role_id() const;
  void set_role_id(int32_t value);
  private:
  int32_t _internal_role_id() const;
  void _internal_set_role_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.UserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  int32_t userid_;
  bool is_roomhost_;
  int32_t role_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class JoinRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.JoinRoom) */ {
 public:
  inline JoinRoom() : JoinRoom(nullptr) {}
  ~JoinRoom() override;
  explicit constexpr JoinRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoom(const JoinRoom& from);
  JoinRoom(JoinRoom&& from) noexcept
    : JoinRoom() {
    *this = ::std::move(from);
  }

  inline JoinRoom& operator=(const JoinRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoom& operator=(JoinRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoom* internal_default_instance() {
    return reinterpret_cast<const JoinRoom*>(
               &_JoinRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JoinRoom& a, JoinRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.JoinRoom";
  }
  protected:
  explicit JoinRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JoinRoom_Type Type;
  static constexpr Type REQUEST =
    JoinRoom_Type_REQUEST;
  static constexpr Type RESPONSE =
    JoinRoom_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return JoinRoom_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    JoinRoom_Type_Type_MIN;
  static constexpr Type Type_MAX =
    JoinRoom_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    JoinRoom_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return JoinRoom_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return JoinRoom_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return JoinRoom_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 5,
    kResultFieldNumber = 2,
    kRoomidFieldNumber = 1,
    kTypeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // repeated .RoomProto.UserInfo users = 5;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::RoomProto::UserInfo* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
      mutable_users();
  private:
  const ::RoomProto::UserInfo& _internal_users(int index) const;
  ::RoomProto::UserInfo* _internal_add_users();
  public:
  const ::RoomProto::UserInfo& users(int index) const;
  ::RoomProto::UserInfo* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
      users() const;

  // string result = 2;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // .RoomProto.JoinRoom.Type type = 3;
  void clear_type();
  ::RoomProto::JoinRoom_Type type() const;
  void set_type(::RoomProto::JoinRoom_Type value);
  private:
  ::RoomProto::JoinRoom_Type _internal_type() const;
  void _internal_set_type(::RoomProto::JoinRoom_Type value);
  public:

  // bool ret = 4;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.JoinRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo > users_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  int32_t roomid_;
  int type_;
  bool ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.LeaveRoom) */ {
 public:
  inline LeaveRoom() : LeaveRoom(nullptr) {}
  ~LeaveRoom() override;
  explicit constexpr LeaveRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoom(const LeaveRoom& from);
  LeaveRoom(LeaveRoom&& from) noexcept
    : LeaveRoom() {
    *this = ::std::move(from);
  }

  inline LeaveRoom& operator=(const LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoom& operator=(LeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoom* internal_default_instance() {
    return reinterpret_cast<const LeaveRoom*>(
               &_LeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LeaveRoom& a, LeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeaveRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.LeaveRoom";
  }
  protected:
  explicit LeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LeaveRoom_Type Type;
  static constexpr Type REQUEST =
    LeaveRoom_Type_REQUEST;
  static constexpr Type RESPONSE =
    LeaveRoom_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return LeaveRoom_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    LeaveRoom_Type_Type_MIN;
  static constexpr Type Type_MAX =
    LeaveRoom_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    LeaveRoom_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return LeaveRoom_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return LeaveRoom_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return LeaveRoom_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 7,
    kResultFieldNumber = 3,
    kRoomidFieldNumber = 1,
    kRetFieldNumber = 2,
    kTypeFieldNumber = 4,
    kUseridFieldNumber = 5,
    kUserpidFieldNumber = 6,
  };
  // repeated .RoomProto.UserInfo users = 7;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::RoomProto::UserInfo* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
      mutable_users();
  private:
  const ::RoomProto::UserInfo& _internal_users(int index) const;
  ::RoomProto::UserInfo* _internal_add_users();
  public:
  const ::RoomProto::UserInfo& users(int index) const;
  ::RoomProto::UserInfo* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
      users() const;

  // string result = 3;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool ret = 2;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // .RoomProto.LeaveRoom.Type type = 4;
  void clear_type();
  ::RoomProto::LeaveRoom_Type type() const;
  void set_type(::RoomProto::LeaveRoom_Type value);
  private:
  ::RoomProto::LeaveRoom_Type _internal_type() const;
  void _internal_set_type(::RoomProto::LeaveRoom_Type value);
  public:

  // int32 userid = 5;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // int32 userpid = 6;
  void clear_userpid();
  int32_t userpid() const;
  void set_userpid(int32_t value);
  private:
  int32_t _internal_userpid() const;
  void _internal_set_userpid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.LeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo > users_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  int32_t roomid_;
  bool ret_;
  int type_;
  int32_t userid_;
  int32_t userpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class CreateRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.CreateRoom) */ {
 public:
  inline CreateRoom() : CreateRoom(nullptr) {}
  ~CreateRoom() override;
  explicit constexpr CreateRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoom(const CreateRoom& from);
  CreateRoom(CreateRoom&& from) noexcept
    : CreateRoom() {
    *this = ::std::move(from);
  }

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoom& operator=(CreateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoom* internal_default_instance() {
    return reinterpret_cast<const CreateRoom*>(
               &_CreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateRoom& a, CreateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.CreateRoom";
  }
  protected:
  explicit CreateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateRoom_Type Type;
  static constexpr Type REQUEST =
    CreateRoom_Type_REQUEST;
  static constexpr Type RESPONSE =
    CreateRoom_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return CreateRoom_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CreateRoom_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CreateRoom_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CreateRoom_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return CreateRoom_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CreateRoom_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CreateRoom_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kRoomnameFieldNumber = 4,
    kRoomidFieldNumber = 1,
    kRetFieldNumber = 2,
    kIsRoomhostFieldNumber = 6,
    kTypeFieldNumber = 5,
  };
  // string result = 3;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // string roomname = 4;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool ret = 2;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // bool is_roomhost = 6;
  void clear_is_roomhost();
  bool is_roomhost() const;
  void set_is_roomhost(bool value);
  private:
  bool _internal_is_roomhost() const;
  void _internal_set_is_roomhost(bool value);
  public:

  // .RoomProto.CreateRoom.Type type = 5;
  void clear_type();
  ::RoomProto::CreateRoom_Type type() const;
  void set_type(::RoomProto::CreateRoom_Type value);
  private:
  ::RoomProto::CreateRoom_Type _internal_type() const;
  void _internal_set_type(::RoomProto::CreateRoom_Type value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.CreateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
  int32_t roomid_;
  bool ret_;
  bool is_roomhost_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit constexpr RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomnameFieldNumber = 3,
    kRoomidFieldNumber = 1,
    kPeopleCountFieldNumber = 2,
  };
  // string roomname = 3;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 people_count = 2;
  void clear_people_count();
  int32_t people_count() const;
  void set_people_count(int32_t value);
  private:
  int32_t _internal_people_count() const;
  void _internal_set_people_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
  int32_t roomid_;
  int32_t people_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class GetRoomList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.GetRoomList) */ {
 public:
  inline GetRoomList() : GetRoomList(nullptr) {}
  ~GetRoomList() override;
  explicit constexpr GetRoomList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRoomList(const GetRoomList& from);
  GetRoomList(GetRoomList&& from) noexcept
    : GetRoomList() {
    *this = ::std::move(from);
  }

  inline GetRoomList& operator=(const GetRoomList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRoomList& operator=(GetRoomList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRoomList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRoomList* internal_default_instance() {
    return reinterpret_cast<const GetRoomList*>(
               &_GetRoomList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetRoomList& a, GetRoomList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRoomList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRoomList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRoomList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRoomList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRoomList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRoomList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRoomList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.GetRoomList";
  }
  protected:
  explicit GetRoomList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetRoomList_Type Type;
  static constexpr Type REQUEST =
    GetRoomList_Type_REQUEST;
  static constexpr Type RESPONSE =
    GetRoomList_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return GetRoomList_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    GetRoomList_Type_Type_MIN;
  static constexpr Type Type_MAX =
    GetRoomList_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    GetRoomList_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return GetRoomList_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return GetRoomList_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return GetRoomList_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoomListFieldNumber = 1,
    kSizeFieldNumber = 2,
    kRetFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // repeated .RoomProto.RoomInfo room_list = 1;
  int room_list_size() const;
  private:
  int _internal_room_list_size() const;
  public:
  void clear_room_list();
  ::RoomProto::RoomInfo* mutable_room_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::RoomInfo >*
      mutable_room_list();
  private:
  const ::RoomProto::RoomInfo& _internal_room_list(int index) const;
  ::RoomProto::RoomInfo* _internal_add_room_list();
  public:
  const ::RoomProto::RoomInfo& room_list(int index) const;
  ::RoomProto::RoomInfo* add_room_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::RoomInfo >&
      room_list() const;

  // int32 size = 2;
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // bool ret = 3;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // .RoomProto.GetRoomList.Type type = 4;
  void clear_type();
  ::RoomProto::GetRoomList_Type type() const;
  void set_type(::RoomProto::GetRoomList_Type value);
  private:
  ::RoomProto::GetRoomList_Type _internal_type() const;
  void _internal_set_type(::RoomProto::GetRoomList_Type value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.GetRoomList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::RoomInfo > room_list_;
  int32_t size_;
  bool ret_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class GetUserList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.GetUserList) */ {
 public:
  inline GetUserList() : GetUserList(nullptr) {}
  ~GetUserList() override;
  explicit constexpr GetUserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserList(const GetUserList& from);
  GetUserList(GetUserList&& from) noexcept
    : GetUserList() {
    *this = ::std::move(from);
  }

  inline GetUserList& operator=(const GetUserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserList& operator=(GetUserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserList* internal_default_instance() {
    return reinterpret_cast<const GetUserList*>(
               &_GetUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetUserList& a, GetUserList& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.GetUserList";
  }
  protected:
  explicit GetUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
    kRoomidFieldNumber = 2,
  };
  // repeated .RoomProto.UserInfo users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::RoomProto::UserInfo* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
      mutable_users();
  private:
  const ::RoomProto::UserInfo& _internal_users(int index) const;
  ::RoomProto::UserInfo* _internal_add_users();
  public:
  const ::RoomProto::UserInfo& users(int index) const;
  ::RoomProto::UserInfo* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
      users() const;

  // int32 roomid = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.GetUserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo > users_;
  int32_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class RoomStatusChangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.RoomStatusChangeRequest) */ {
 public:
  inline RoomStatusChangeRequest() : RoomStatusChangeRequest(nullptr) {}
  ~RoomStatusChangeRequest() override;
  explicit constexpr RoomStatusChangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomStatusChangeRequest(const RoomStatusChangeRequest& from);
  RoomStatusChangeRequest(RoomStatusChangeRequest&& from) noexcept
    : RoomStatusChangeRequest() {
    *this = ::std::move(from);
  }

  inline RoomStatusChangeRequest& operator=(const RoomStatusChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomStatusChangeRequest& operator=(RoomStatusChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomStatusChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomStatusChangeRequest* internal_default_instance() {
    return reinterpret_cast<const RoomStatusChangeRequest*>(
               &_RoomStatusChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoomStatusChangeRequest& a, RoomStatusChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomStatusChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomStatusChangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomStatusChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomStatusChangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomStatusChangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomStatusChangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomStatusChangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.RoomStatusChangeRequest";
  }
  protected:
  explicit RoomStatusChangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int32 role_id = 1;
  void clear_role_id();
  int32_t role_id() const;
  void set_role_id(int32_t value);
  private:
  int32_t _internal_role_id() const;
  void _internal_set_role_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.RoomStatusChangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t role_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class RoomStatusChangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.RoomStatusChangeResponse) */ {
 public:
  inline RoomStatusChangeResponse() : RoomStatusChangeResponse(nullptr) {}
  ~RoomStatusChangeResponse() override;
  explicit constexpr RoomStatusChangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomStatusChangeResponse(const RoomStatusChangeResponse& from);
  RoomStatusChangeResponse(RoomStatusChangeResponse&& from) noexcept
    : RoomStatusChangeResponse() {
    *this = ::std::move(from);
  }

  inline RoomStatusChangeResponse& operator=(const RoomStatusChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomStatusChangeResponse& operator=(RoomStatusChangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomStatusChangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomStatusChangeResponse* internal_default_instance() {
    return reinterpret_cast<const RoomStatusChangeResponse*>(
               &_RoomStatusChangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomStatusChangeResponse& a, RoomStatusChangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomStatusChangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomStatusChangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomStatusChangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomStatusChangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomStatusChangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomStatusChangeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomStatusChangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.RoomStatusChangeResponse";
  }
  protected:
  explicit RoomStatusChangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kRoleIdFieldNumber = 2,
  };
  // int32 userid = 1;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // int32 role_id = 2;
  void clear_role_id();
  int32_t role_id() const;
  void set_role_id(int32_t value);
  private:
  int32_t _internal_role_id() const;
  void _internal_set_role_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.RoomStatusChangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t userid_;
  int32_t role_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class JoinGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.JoinGame) */ {
 public:
  inline JoinGame() : JoinGame(nullptr) {}
  ~JoinGame() override;
  explicit constexpr JoinGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinGame(const JoinGame& from);
  JoinGame(JoinGame&& from) noexcept
    : JoinGame() {
    *this = ::std::move(from);
  }

  inline JoinGame& operator=(const JoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinGame& operator=(JoinGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinGame* internal_default_instance() {
    return reinterpret_cast<const JoinGame*>(
               &_JoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(JoinGame& a, JoinGame& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.JoinGame";
  }
  protected:
  explicit JoinGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // int32 userid = 1;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.JoinGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// -------------------------------------------------------------------

class QuitGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomProto.QuitGame) */ {
 public:
  inline QuitGame() : QuitGame(nullptr) {}
  ~QuitGame() override;
  explicit constexpr QuitGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuitGame(const QuitGame& from);
  QuitGame(QuitGame&& from) noexcept
    : QuitGame() {
    *this = ::std::move(from);
  }

  inline QuitGame& operator=(const QuitGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuitGame& operator=(QuitGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuitGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuitGame* internal_default_instance() {
    return reinterpret_cast<const QuitGame*>(
               &_QuitGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QuitGame& a, QuitGame& b) {
    a.Swap(&b);
  }
  inline void Swap(QuitGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuitGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuitGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuitGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuitGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuitGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuitGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomProto.QuitGame";
  }
  protected:
  explicit QuitGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
  };
  // int32 userid = 1;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomProto.QuitGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Room_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserInfo

// string username = 1;
inline void UserInfo::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserInfo::username() const {
  // @@protoc_insertion_point(field_get:RoomProto.UserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.UserInfo.username)
}
inline std::string* UserInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:RoomProto.UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  return username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserInfo::release_username() {
  // @@protoc_insertion_point(field_release:RoomProto.UserInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.UserInfo.username)
}

// int32 userid = 2;
inline void UserInfo::clear_userid() {
  userid_ = 0;
}
inline int32_t UserInfo::_internal_userid() const {
  return userid_;
}
inline int32_t UserInfo::userid() const {
  // @@protoc_insertion_point(field_get:RoomProto.UserInfo.userid)
  return _internal_userid();
}
inline void UserInfo::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void UserInfo::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:RoomProto.UserInfo.userid)
}

// bool is_roomHost = 3;
inline void UserInfo::clear_is_roomhost() {
  is_roomhost_ = false;
}
inline bool UserInfo::_internal_is_roomhost() const {
  return is_roomhost_;
}
inline bool UserInfo::is_roomhost() const {
  // @@protoc_insertion_point(field_get:RoomProto.UserInfo.is_roomHost)
  return _internal_is_roomhost();
}
inline void UserInfo::_internal_set_is_roomhost(bool value) {
  
  is_roomhost_ = value;
}
inline void UserInfo::set_is_roomhost(bool value) {
  _internal_set_is_roomhost(value);
  // @@protoc_insertion_point(field_set:RoomProto.UserInfo.is_roomHost)
}

// int32 role_id = 4;
inline void UserInfo::clear_role_id() {
  role_id_ = 0;
}
inline int32_t UserInfo::_internal_role_id() const {
  return role_id_;
}
inline int32_t UserInfo::role_id() const {
  // @@protoc_insertion_point(field_get:RoomProto.UserInfo.role_id)
  return _internal_role_id();
}
inline void UserInfo::_internal_set_role_id(int32_t value) {
  
  role_id_ = value;
}
inline void UserInfo::set_role_id(int32_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:RoomProto.UserInfo.role_id)
}

// -------------------------------------------------------------------

// JoinRoom

// int32 roomid = 1;
inline void JoinRoom::clear_roomid() {
  roomid_ = 0;
}
inline int32_t JoinRoom::_internal_roomid() const {
  return roomid_;
}
inline int32_t JoinRoom::roomid() const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinRoom.roomid)
  return _internal_roomid();
}
inline void JoinRoom::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void JoinRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomProto.JoinRoom.roomid)
}

// string result = 2;
inline void JoinRoom::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& JoinRoom::result() const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinRoom.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoom::set_result(ArgT0&& arg0, ArgT... args) {
 
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.JoinRoom.result)
}
inline std::string* JoinRoom::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:RoomProto.JoinRoom.result)
  return _s;
}
inline const std::string& JoinRoom::_internal_result() const {
  return result_.Get();
}
inline void JoinRoom::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JoinRoom::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JoinRoom::release_result() {
  // @@protoc_insertion_point(field_release:RoomProto.JoinRoom.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JoinRoom::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.JoinRoom.result)
}

// .RoomProto.JoinRoom.Type type = 3;
inline void JoinRoom::clear_type() {
  type_ = 0;
}
inline ::RoomProto::JoinRoom_Type JoinRoom::_internal_type() const {
  return static_cast< ::RoomProto::JoinRoom_Type >(type_);
}
inline ::RoomProto::JoinRoom_Type JoinRoom::type() const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinRoom.type)
  return _internal_type();
}
inline void JoinRoom::_internal_set_type(::RoomProto::JoinRoom_Type value) {
  
  type_ = value;
}
inline void JoinRoom::set_type(::RoomProto::JoinRoom_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoomProto.JoinRoom.type)
}

// bool ret = 4;
inline void JoinRoom::clear_ret() {
  ret_ = false;
}
inline bool JoinRoom::_internal_ret() const {
  return ret_;
}
inline bool JoinRoom::ret() const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinRoom.ret)
  return _internal_ret();
}
inline void JoinRoom::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void JoinRoom::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RoomProto.JoinRoom.ret)
}

// repeated .RoomProto.UserInfo users = 5;
inline int JoinRoom::_internal_users_size() const {
  return users_.size();
}
inline int JoinRoom::users_size() const {
  return _internal_users_size();
}
inline void JoinRoom::clear_users() {
  users_.Clear();
}
inline ::RoomProto::UserInfo* JoinRoom::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:RoomProto.JoinRoom.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
JoinRoom::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:RoomProto.JoinRoom.users)
  return &users_;
}
inline const ::RoomProto::UserInfo& JoinRoom::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::RoomProto::UserInfo& JoinRoom::users(int index) const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinRoom.users)
  return _internal_users(index);
}
inline ::RoomProto::UserInfo* JoinRoom::_internal_add_users() {
  return users_.Add();
}
inline ::RoomProto::UserInfo* JoinRoom::add_users() {
  ::RoomProto::UserInfo* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:RoomProto.JoinRoom.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
JoinRoom::users() const {
  // @@protoc_insertion_point(field_list:RoomProto.JoinRoom.users)
  return users_;
}

// -------------------------------------------------------------------

// LeaveRoom

// int32 roomid = 1;
inline void LeaveRoom::clear_roomid() {
  roomid_ = 0;
}
inline int32_t LeaveRoom::_internal_roomid() const {
  return roomid_;
}
inline int32_t LeaveRoom::roomid() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.roomid)
  return _internal_roomid();
}
inline void LeaveRoom::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void LeaveRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.roomid)
}

// bool ret = 2;
inline void LeaveRoom::clear_ret() {
  ret_ = false;
}
inline bool LeaveRoom::_internal_ret() const {
  return ret_;
}
inline bool LeaveRoom::ret() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.ret)
  return _internal_ret();
}
inline void LeaveRoom::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void LeaveRoom::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.ret)
}

// string result = 3;
inline void LeaveRoom::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& LeaveRoom::result() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LeaveRoom::set_result(ArgT0&& arg0, ArgT... args) {
 
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.result)
}
inline std::string* LeaveRoom::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:RoomProto.LeaveRoom.result)
  return _s;
}
inline const std::string& LeaveRoom::_internal_result() const {
  return result_.Get();
}
inline void LeaveRoom::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LeaveRoom::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LeaveRoom::release_result() {
  // @@protoc_insertion_point(field_release:RoomProto.LeaveRoom.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LeaveRoom::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.LeaveRoom.result)
}

// .RoomProto.LeaveRoom.Type type = 4;
inline void LeaveRoom::clear_type() {
  type_ = 0;
}
inline ::RoomProto::LeaveRoom_Type LeaveRoom::_internal_type() const {
  return static_cast< ::RoomProto::LeaveRoom_Type >(type_);
}
inline ::RoomProto::LeaveRoom_Type LeaveRoom::type() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.type)
  return _internal_type();
}
inline void LeaveRoom::_internal_set_type(::RoomProto::LeaveRoom_Type value) {
  
  type_ = value;
}
inline void LeaveRoom::set_type(::RoomProto::LeaveRoom_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.type)
}

// int32 userid = 5;
inline void LeaveRoom::clear_userid() {
  userid_ = 0;
}
inline int32_t LeaveRoom::_internal_userid() const {
  return userid_;
}
inline int32_t LeaveRoom::userid() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.userid)
  return _internal_userid();
}
inline void LeaveRoom::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void LeaveRoom::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.userid)
}

// int32 userpid = 6;
inline void LeaveRoom::clear_userpid() {
  userpid_ = 0;
}
inline int32_t LeaveRoom::_internal_userpid() const {
  return userpid_;
}
inline int32_t LeaveRoom::userpid() const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.userpid)
  return _internal_userpid();
}
inline void LeaveRoom::_internal_set_userpid(int32_t value) {
  
  userpid_ = value;
}
inline void LeaveRoom::set_userpid(int32_t value) {
  _internal_set_userpid(value);
  // @@protoc_insertion_point(field_set:RoomProto.LeaveRoom.userpid)
}

// repeated .RoomProto.UserInfo users = 7;
inline int LeaveRoom::_internal_users_size() const {
  return users_.size();
}
inline int LeaveRoom::users_size() const {
  return _internal_users_size();
}
inline void LeaveRoom::clear_users() {
  users_.Clear();
}
inline ::RoomProto::UserInfo* LeaveRoom::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:RoomProto.LeaveRoom.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
LeaveRoom::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:RoomProto.LeaveRoom.users)
  return &users_;
}
inline const ::RoomProto::UserInfo& LeaveRoom::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::RoomProto::UserInfo& LeaveRoom::users(int index) const {
  // @@protoc_insertion_point(field_get:RoomProto.LeaveRoom.users)
  return _internal_users(index);
}
inline ::RoomProto::UserInfo* LeaveRoom::_internal_add_users() {
  return users_.Add();
}
inline ::RoomProto::UserInfo* LeaveRoom::add_users() {
  ::RoomProto::UserInfo* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:RoomProto.LeaveRoom.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
LeaveRoom::users() const {
  // @@protoc_insertion_point(field_list:RoomProto.LeaveRoom.users)
  return users_;
}

// -------------------------------------------------------------------

// CreateRoom

// int32 roomid = 1;
inline void CreateRoom::clear_roomid() {
  roomid_ = 0;
}
inline int32_t CreateRoom::_internal_roomid() const {
  return roomid_;
}
inline int32_t CreateRoom::roomid() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.roomid)
  return _internal_roomid();
}
inline void CreateRoom::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void CreateRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.roomid)
}

// bool ret = 2;
inline void CreateRoom::clear_ret() {
  ret_ = false;
}
inline bool CreateRoom::_internal_ret() const {
  return ret_;
}
inline bool CreateRoom::ret() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.ret)
  return _internal_ret();
}
inline void CreateRoom::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void CreateRoom::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.ret)
}

// string result = 3;
inline void CreateRoom::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& CreateRoom::result() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoom::set_result(ArgT0&& arg0, ArgT... args) {
 
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.result)
}
inline std::string* CreateRoom::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:RoomProto.CreateRoom.result)
  return _s;
}
inline const std::string& CreateRoom::_internal_result() const {
  return result_.Get();
}
inline void CreateRoom::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRoom::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRoom::release_result() {
  // @@protoc_insertion_point(field_release:RoomProto.CreateRoom.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRoom::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.CreateRoom.result)
}

// string roomname = 4;
inline void CreateRoom::clear_roomname() {
  roomname_.ClearToEmpty();
}
inline const std::string& CreateRoom::roomname() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.roomname)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoom::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 roomname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.roomname)
}
inline std::string* CreateRoom::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:RoomProto.CreateRoom.roomname)
  return _s;
}
inline const std::string& CreateRoom::_internal_roomname() const {
  return roomname_.Get();
}
inline void CreateRoom::_internal_set_roomname(const std::string& value) {
  
  roomname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRoom::_internal_mutable_roomname() {
  
  return roomname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomProto.CreateRoom.roomname)
  return roomname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRoom::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  roomname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roomname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.CreateRoom.roomname)
}

// .RoomProto.CreateRoom.Type type = 5;
inline void CreateRoom::clear_type() {
  type_ = 0;
}
inline ::RoomProto::CreateRoom_Type CreateRoom::_internal_type() const {
  return static_cast< ::RoomProto::CreateRoom_Type >(type_);
}
inline ::RoomProto::CreateRoom_Type CreateRoom::type() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.type)
  return _internal_type();
}
inline void CreateRoom::_internal_set_type(::RoomProto::CreateRoom_Type value) {
  
  type_ = value;
}
inline void CreateRoom::set_type(::RoomProto::CreateRoom_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.type)
}

// bool is_roomhost = 6;
inline void CreateRoom::clear_is_roomhost() {
  is_roomhost_ = false;
}
inline bool CreateRoom::_internal_is_roomhost() const {
  return is_roomhost_;
}
inline bool CreateRoom::is_roomhost() const {
  // @@protoc_insertion_point(field_get:RoomProto.CreateRoom.is_roomhost)
  return _internal_is_roomhost();
}
inline void CreateRoom::_internal_set_is_roomhost(bool value) {
  
  is_roomhost_ = value;
}
inline void CreateRoom::set_is_roomhost(bool value) {
  _internal_set_is_roomhost(value);
  // @@protoc_insertion_point(field_set:RoomProto.CreateRoom.is_roomhost)
}

// -------------------------------------------------------------------

// RoomInfo

// int32 roomid = 1;
inline void RoomInfo::clear_roomid() {
  roomid_ = 0;
}
inline int32_t RoomInfo::_internal_roomid() const {
  return roomid_;
}
inline int32_t RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomInfo.roomid)
  return _internal_roomid();
}
inline void RoomInfo::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void RoomInfo::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomProto.RoomInfo.roomid)
}

// int32 people_count = 2;
inline void RoomInfo::clear_people_count() {
  people_count_ = 0;
}
inline int32_t RoomInfo::_internal_people_count() const {
  return people_count_;
}
inline int32_t RoomInfo::people_count() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomInfo.people_count)
  return _internal_people_count();
}
inline void RoomInfo::_internal_set_people_count(int32_t value) {
  
  people_count_ = value;
}
inline void RoomInfo::set_people_count(int32_t value) {
  _internal_set_people_count(value);
  // @@protoc_insertion_point(field_set:RoomProto.RoomInfo.people_count)
}

// string roomname = 3;
inline void RoomInfo::clear_roomname() {
  roomname_.ClearToEmpty();
}
inline const std::string& RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomInfo.roomname)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 roomname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RoomProto.RoomInfo.roomname)
}
inline std::string* RoomInfo::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:RoomProto.RoomInfo.roomname)
  return _s;
}
inline const std::string& RoomInfo::_internal_roomname() const {
  return roomname_.Get();
}
inline void RoomInfo::_internal_set_roomname(const std::string& value) {
  
  roomname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_roomname() {
  
  return roomname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomProto.RoomInfo.roomname)
  return roomname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RoomInfo::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  roomname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roomname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RoomProto.RoomInfo.roomname)
}

// -------------------------------------------------------------------

// GetRoomList

// repeated .RoomProto.RoomInfo room_list = 1;
inline int GetRoomList::_internal_room_list_size() const {
  return room_list_.size();
}
inline int GetRoomList::room_list_size() const {
  return _internal_room_list_size();
}
inline void GetRoomList::clear_room_list() {
  room_list_.Clear();
}
inline ::RoomProto::RoomInfo* GetRoomList::mutable_room_list(int index) {
  // @@protoc_insertion_point(field_mutable:RoomProto.GetRoomList.room_list)
  return room_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::RoomInfo >*
GetRoomList::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:RoomProto.GetRoomList.room_list)
  return &room_list_;
}
inline const ::RoomProto::RoomInfo& GetRoomList::_internal_room_list(int index) const {
  return room_list_.Get(index);
}
inline const ::RoomProto::RoomInfo& GetRoomList::room_list(int index) const {
  // @@protoc_insertion_point(field_get:RoomProto.GetRoomList.room_list)
  return _internal_room_list(index);
}
inline ::RoomProto::RoomInfo* GetRoomList::_internal_add_room_list() {
  return room_list_.Add();
}
inline ::RoomProto::RoomInfo* GetRoomList::add_room_list() {
  ::RoomProto::RoomInfo* _add = _internal_add_room_list();
  // @@protoc_insertion_point(field_add:RoomProto.GetRoomList.room_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::RoomInfo >&
GetRoomList::room_list() const {
  // @@protoc_insertion_point(field_list:RoomProto.GetRoomList.room_list)
  return room_list_;
}

// int32 size = 2;
inline void GetRoomList::clear_size() {
  size_ = 0;
}
inline int32_t GetRoomList::_internal_size() const {
  return size_;
}
inline int32_t GetRoomList::size() const {
  // @@protoc_insertion_point(field_get:RoomProto.GetRoomList.size)
  return _internal_size();
}
inline void GetRoomList::_internal_set_size(int32_t value) {
  
  size_ = value;
}
inline void GetRoomList::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:RoomProto.GetRoomList.size)
}

// bool ret = 3;
inline void GetRoomList::clear_ret() {
  ret_ = false;
}
inline bool GetRoomList::_internal_ret() const {
  return ret_;
}
inline bool GetRoomList::ret() const {
  // @@protoc_insertion_point(field_get:RoomProto.GetRoomList.ret)
  return _internal_ret();
}
inline void GetRoomList::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void GetRoomList::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:RoomProto.GetRoomList.ret)
}

// .RoomProto.GetRoomList.Type type = 4;
inline void GetRoomList::clear_type() {
  type_ = 0;
}
inline ::RoomProto::GetRoomList_Type GetRoomList::_internal_type() const {
  return static_cast< ::RoomProto::GetRoomList_Type >(type_);
}
inline ::RoomProto::GetRoomList_Type GetRoomList::type() const {
  // @@protoc_insertion_point(field_get:RoomProto.GetRoomList.type)
  return _internal_type();
}
inline void GetRoomList::_internal_set_type(::RoomProto::GetRoomList_Type value) {
  
  type_ = value;
}
inline void GetRoomList::set_type(::RoomProto::GetRoomList_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RoomProto.GetRoomList.type)
}

// -------------------------------------------------------------------

// GetUserList

// repeated .RoomProto.UserInfo users = 1;
inline int GetUserList::_internal_users_size() const {
  return users_.size();
}
inline int GetUserList::users_size() const {
  return _internal_users_size();
}
inline void GetUserList::clear_users() {
  users_.Clear();
}
inline ::RoomProto::UserInfo* GetUserList::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:RoomProto.GetUserList.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >*
GetUserList::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:RoomProto.GetUserList.users)
  return &users_;
}
inline const ::RoomProto::UserInfo& GetUserList::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::RoomProto::UserInfo& GetUserList::users(int index) const {
  // @@protoc_insertion_point(field_get:RoomProto.GetUserList.users)
  return _internal_users(index);
}
inline ::RoomProto::UserInfo* GetUserList::_internal_add_users() {
  return users_.Add();
}
inline ::RoomProto::UserInfo* GetUserList::add_users() {
  ::RoomProto::UserInfo* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:RoomProto.GetUserList.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomProto::UserInfo >&
GetUserList::users() const {
  // @@protoc_insertion_point(field_list:RoomProto.GetUserList.users)
  return users_;
}

// int32 roomid = 2;
inline void GetUserList::clear_roomid() {
  roomid_ = 0;
}
inline int32_t GetUserList::_internal_roomid() const {
  return roomid_;
}
inline int32_t GetUserList::roomid() const {
  // @@protoc_insertion_point(field_get:RoomProto.GetUserList.roomid)
  return _internal_roomid();
}
inline void GetUserList::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void GetUserList::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomProto.GetUserList.roomid)
}

// -------------------------------------------------------------------

// RoomStatusChangeRequest

// int32 role_id = 1;
inline void RoomStatusChangeRequest::clear_role_id() {
  role_id_ = 0;
}
inline int32_t RoomStatusChangeRequest::_internal_role_id() const {
  return role_id_;
}
inline int32_t RoomStatusChangeRequest::role_id() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomStatusChangeRequest.role_id)
  return _internal_role_id();
}
inline void RoomStatusChangeRequest::_internal_set_role_id(int32_t value) {
  
  role_id_ = value;
}
inline void RoomStatusChangeRequest::set_role_id(int32_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:RoomProto.RoomStatusChangeRequest.role_id)
}

// -------------------------------------------------------------------

// RoomStatusChangeResponse

// int32 userid = 1;
inline void RoomStatusChangeResponse::clear_userid() {
  userid_ = 0;
}
inline int32_t RoomStatusChangeResponse::_internal_userid() const {
  return userid_;
}
inline int32_t RoomStatusChangeResponse::userid() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomStatusChangeResponse.userid)
  return _internal_userid();
}
inline void RoomStatusChangeResponse::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void RoomStatusChangeResponse::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:RoomProto.RoomStatusChangeResponse.userid)
}

// int32 role_id = 2;
inline void RoomStatusChangeResponse::clear_role_id() {
  role_id_ = 0;
}
inline int32_t RoomStatusChangeResponse::_internal_role_id() const {
  return role_id_;
}
inline int32_t RoomStatusChangeResponse::role_id() const {
  // @@protoc_insertion_point(field_get:RoomProto.RoomStatusChangeResponse.role_id)
  return _internal_role_id();
}
inline void RoomStatusChangeResponse::_internal_set_role_id(int32_t value) {
  
  role_id_ = value;
}
inline void RoomStatusChangeResponse::set_role_id(int32_t value) {
  _internal_set_role_id(value);
  // @@protoc_insertion_point(field_set:RoomProto.RoomStatusChangeResponse.role_id)
}

// -------------------------------------------------------------------

// JoinGame

// int32 userid = 1;
inline void JoinGame::clear_userid() {
  userid_ = 0;
}
inline int32_t JoinGame::_internal_userid() const {
  return userid_;
}
inline int32_t JoinGame::userid() const {
  // @@protoc_insertion_point(field_get:RoomProto.JoinGame.userid)
  return _internal_userid();
}
inline void JoinGame::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void JoinGame::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:RoomProto.JoinGame.userid)
}

// -------------------------------------------------------------------

// QuitGame

// int32 userid = 1;
inline void QuitGame::clear_userid() {
  userid_ = 0;
}
inline int32_t QuitGame::_internal_userid() const {
  return userid_;
}
inline int32_t QuitGame::userid() const {
  // @@protoc_insertion_point(field_get:RoomProto.QuitGame.userid)
  return _internal_userid();
}
inline void QuitGame::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void QuitGame::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:RoomProto.QuitGame.userid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoomProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RoomProto::JoinRoom_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomProto::JoinRoom_Type>() {
  return ::RoomProto::JoinRoom_Type_descriptor();
}
template <> struct is_proto_enum< ::RoomProto::LeaveRoom_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomProto::LeaveRoom_Type>() {
  return ::RoomProto::LeaveRoom_Type_descriptor();
}
template <> struct is_proto_enum< ::RoomProto::CreateRoom_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomProto::CreateRoom_Type>() {
  return ::RoomProto::CreateRoom_Type_descriptor();
}
template <> struct is_proto_enum< ::RoomProto::GetRoomList_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomProto::GetRoomList_Type>() {
  return ::RoomProto::GetRoomList_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Room_2eproto
