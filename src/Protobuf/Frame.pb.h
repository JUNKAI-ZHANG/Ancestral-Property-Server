// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Frame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Frame_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Frame_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Frame_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Frame_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Frame_2eproto;
namespace FrameProto {
class ChaseFrame;
struct ChaseFrameDefaultTypeInternal;
extern ChaseFrameDefaultTypeInternal _ChaseFrame_default_instance_;
class EndGame;
struct EndGameDefaultTypeInternal;
extern EndGameDefaultTypeInternal _EndGame_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class GameReplay;
struct GameReplayDefaultTypeInternal;
extern GameReplayDefaultTypeInternal _GameReplay_default_instance_;
class Reconnect;
struct ReconnectDefaultTypeInternal;
extern ReconnectDefaultTypeInternal _Reconnect_default_instance_;
class StartGame;
struct StartGameDefaultTypeInternal;
extern StartGameDefaultTypeInternal _StartGame_default_instance_;
class UserOperate;
struct UserOperateDefaultTypeInternal;
extern UserOperateDefaultTypeInternal _UserOperate_default_instance_;
}  // namespace FrameProto
PROTOBUF_NAMESPACE_OPEN
template<> ::FrameProto::ChaseFrame* Arena::CreateMaybeMessage<::FrameProto::ChaseFrame>(Arena*);
template<> ::FrameProto::EndGame* Arena::CreateMaybeMessage<::FrameProto::EndGame>(Arena*);
template<> ::FrameProto::Frame* Arena::CreateMaybeMessage<::FrameProto::Frame>(Arena*);
template<> ::FrameProto::GameReplay* Arena::CreateMaybeMessage<::FrameProto::GameReplay>(Arena*);
template<> ::FrameProto::Reconnect* Arena::CreateMaybeMessage<::FrameProto::Reconnect>(Arena*);
template<> ::FrameProto::StartGame* Arena::CreateMaybeMessage<::FrameProto::StartGame>(Arena*);
template<> ::FrameProto::UserOperate* Arena::CreateMaybeMessage<::FrameProto::UserOperate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace FrameProto {

enum OperateType : int {
  FrameInfo = 0,
  JoinGame = 1,
  LeaveGame = 2,
  OperateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperateType_IsValid(int value);
constexpr OperateType OperateType_MIN = FrameInfo;
constexpr OperateType OperateType_MAX = LeaveGame;
constexpr int OperateType_ARRAYSIZE = OperateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperateType_descriptor();
template<typename T>
inline const std::string& OperateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperateType_descriptor(), enum_t_value);
}
inline bool OperateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperateType>(
    OperateType_descriptor(), name, value);
}
// ===================================================================

class StartGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.StartGame) */ {
 public:
  inline StartGame() : StartGame(nullptr) {}
  ~StartGame() override;
  explicit constexpr StartGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartGame(const StartGame& from);
  StartGame(StartGame&& from) noexcept
    : StartGame() {
    *this = ::std::move(from);
  }

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGame& operator=(StartGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartGame* internal_default_instance() {
    return reinterpret_cast<const StartGame*>(
               &_StartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StartGame& a, StartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.StartGame";
  }
  protected:
  explicit StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
    kUserpidFieldNumber = 2,
    kSeedFieldNumber = 3,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 userpid = 2;
  void clear_userpid();
  int32_t userpid() const;
  void set_userpid(int32_t value);
  private:
  int32_t _internal_userpid() const;
  void _internal_set_userpid(int32_t value);
  public:

  // uint32 seed = 3;
  void clear_seed();
  uint32_t seed() const;
  void set_seed(uint32_t value);
  private:
  uint32_t _internal_seed() const;
  void _internal_set_seed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:FrameProto.StartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roomid_;
  int32_t userpid_;
  uint32_t seed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class EndGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.EndGame) */ {
 public:
  inline EndGame() : EndGame(nullptr) {}
  ~EndGame() override;
  explicit constexpr EndGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndGame(const EndGame& from);
  EndGame(EndGame&& from) noexcept
    : EndGame() {
    *this = ::std::move(from);
  }

  inline EndGame& operator=(const EndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndGame& operator=(EndGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EndGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndGame* internal_default_instance() {
    return reinterpret_cast<const EndGame*>(
               &_EndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EndGame& a, EndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(EndGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EndGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EndGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.EndGame";
  }
  protected:
  explicit EndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:FrameProto.EndGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class UserOperate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.UserOperate) */ {
 public:
  inline UserOperate() : UserOperate(nullptr) {}
  ~UserOperate() override;
  explicit constexpr UserOperate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserOperate(const UserOperate& from);
  UserOperate(UserOperate&& from) noexcept
    : UserOperate() {
    *this = ::std::move(from);
  }

  inline UserOperate& operator=(const UserOperate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserOperate& operator=(UserOperate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserOperate& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserOperate* internal_default_instance() {
    return reinterpret_cast<const UserOperate*>(
               &_UserOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserOperate& a, UserOperate& b) {
    a.Swap(&b);
  }
  inline void Swap(UserOperate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserOperate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserOperate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserOperate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserOperate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserOperate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserOperate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.UserOperate";
  }
  protected:
  explicit UserOperate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kOptFieldNumber = 2,
    kUserpidFieldNumber = 3,
  };
  // repeated int64 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  int64_t _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_data() const;
  void _internal_add_data(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_data();
  public:
  int64_t data(int index) const;
  void set_data(int index, int64_t value);
  void add_data(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_data();

  // .FrameProto.OperateType opt = 2;
  void clear_opt();
  ::FrameProto::OperateType opt() const;
  void set_opt(::FrameProto::OperateType value);
  private:
  ::FrameProto::OperateType _internal_opt() const;
  void _internal_set_opt(::FrameProto::OperateType value);
  public:

  // int32 userpid = 3;
  void clear_userpid();
  int32_t userpid() const;
  void set_userpid(int32_t value);
  private:
  int32_t _internal_userpid() const;
  void _internal_set_userpid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:FrameProto.UserOperate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  int opt_;
  int32_t userpid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class Reconnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.Reconnect) */ {
 public:
  inline Reconnect() : Reconnect(nullptr) {}
  ~Reconnect() override;
  explicit constexpr Reconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reconnect(const Reconnect& from);
  Reconnect(Reconnect&& from) noexcept
    : Reconnect() {
    *this = ::std::move(from);
  }

  inline Reconnect& operator=(const Reconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reconnect& operator=(Reconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reconnect* internal_default_instance() {
    return reinterpret_cast<const Reconnect*>(
               &_Reconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Reconnect& a, Reconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(Reconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reconnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Reconnect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reconnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.Reconnect";
  }
  protected:
  explicit Reconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 7,
    kRoomidFieldNumber = 1,
    kUserpidFieldNumber = 2,
    kSeedFieldNumber = 4,
    kIsRoomhostFieldNumber = 3,
    kRetFieldNumber = 6,
    kTokenFieldNumber = 5,
  };
  // string msg = 7;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 userpid = 2;
  void clear_userpid();
  int32_t userpid() const;
  void set_userpid(int32_t value);
  private:
  int32_t _internal_userpid() const;
  void _internal_set_userpid(int32_t value);
  public:

  // uint32 seed = 4;
  void clear_seed();
  uint32_t seed() const;
  void set_seed(uint32_t value);
  private:
  uint32_t _internal_seed() const;
  void _internal_set_seed(uint32_t value);
  public:

  // bool is_roomhost = 3;
  void clear_is_roomhost();
  bool is_roomhost() const;
  void set_is_roomhost(bool value);
  private:
  bool _internal_is_roomhost() const;
  void _internal_set_is_roomhost(bool value);
  public:

  // bool ret = 6;
  void clear_ret();
  bool ret() const;
  void set_ret(bool value);
  private:
  bool _internal_ret() const;
  void _internal_set_ret(bool value);
  public:

  // int32 token = 5;
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:FrameProto.Reconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int32_t roomid_;
  int32_t userpid_;
  uint32_t seed_;
  bool is_roomhost_;
  bool ret_;
  int32_t token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit constexpr Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Frame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatesFieldNumber = 2,
    kFrameIdFieldNumber = 1,
  };
  // repeated .FrameProto.UserOperate operates = 2;
  int operates_size() const;
  private:
  int _internal_operates_size() const;
  public:
  void clear_operates();
  ::FrameProto::UserOperate* mutable_operates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::UserOperate >*
      mutable_operates();
  private:
  const ::FrameProto::UserOperate& _internal_operates(int index) const;
  ::FrameProto::UserOperate* _internal_add_operates();
  public:
  const ::FrameProto::UserOperate& operates(int index) const;
  ::FrameProto::UserOperate* add_operates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::UserOperate >&
      operates() const;

  // int32 frame_id = 1;
  void clear_frame_id();
  int32_t frame_id() const;
  void set_frame_id(int32_t value);
  private:
  int32_t _internal_frame_id() const;
  void _internal_set_frame_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:FrameProto.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::UserOperate > operates_;
  int32_t frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class ChaseFrame final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:FrameProto.ChaseFrame) */ {
 public:
  inline ChaseFrame() : ChaseFrame(nullptr) {}
  explicit constexpr ChaseFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChaseFrame(const ChaseFrame& from);
  ChaseFrame(ChaseFrame&& from) noexcept
    : ChaseFrame() {
    *this = ::std::move(from);
  }

  inline ChaseFrame& operator=(const ChaseFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChaseFrame& operator=(ChaseFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChaseFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChaseFrame* internal_default_instance() {
    return reinterpret_cast<const ChaseFrame*>(
               &_ChaseFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChaseFrame& a, ChaseFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ChaseFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChaseFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChaseFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChaseFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChaseFrame& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChaseFrame& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.ChaseFrame";
  }
  protected:
  explicit ChaseFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:FrameProto.ChaseFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// -------------------------------------------------------------------

class GameReplay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FrameProto.GameReplay) */ {
 public:
  inline GameReplay() : GameReplay(nullptr) {}
  ~GameReplay() override;
  explicit constexpr GameReplay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameReplay(const GameReplay& from);
  GameReplay(GameReplay&& from) noexcept
    : GameReplay() {
    *this = ::std::move(from);
  }

  inline GameReplay& operator=(const GameReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameReplay& operator=(GameReplay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameReplay& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameReplay* internal_default_instance() {
    return reinterpret_cast<const GameReplay*>(
               &_GameReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameReplay& a, GameReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(GameReplay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameReplay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameReplay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameReplay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameReplay& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameReplay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FrameProto.GameReplay";
  }
  protected:
  explicit GameReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 1,
  };
  // repeated .FrameProto.Frame frames = 1;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::FrameProto::Frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::Frame >*
      mutable_frames();
  private:
  const ::FrameProto::Frame& _internal_frames(int index) const;
  ::FrameProto::Frame* _internal_add_frames();
  public:
  const ::FrameProto::Frame& frames(int index) const;
  ::FrameProto::Frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::Frame >&
      frames() const;

  // @@protoc_insertion_point(class_scope:FrameProto.GameReplay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::Frame > frames_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Frame_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StartGame

// int32 roomid = 1;
inline void StartGame::clear_roomid() {
  roomid_ = 0;
}
inline int32_t StartGame::_internal_roomid() const {
  return roomid_;
}
inline int32_t StartGame::roomid() const {
  // @@protoc_insertion_point(field_get:FrameProto.StartGame.roomid)
  return _internal_roomid();
}
inline void StartGame::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void StartGame::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:FrameProto.StartGame.roomid)
}

// int32 userpid = 2;
inline void StartGame::clear_userpid() {
  userpid_ = 0;
}
inline int32_t StartGame::_internal_userpid() const {
  return userpid_;
}
inline int32_t StartGame::userpid() const {
  // @@protoc_insertion_point(field_get:FrameProto.StartGame.userpid)
  return _internal_userpid();
}
inline void StartGame::_internal_set_userpid(int32_t value) {
  
  userpid_ = value;
}
inline void StartGame::set_userpid(int32_t value) {
  _internal_set_userpid(value);
  // @@protoc_insertion_point(field_set:FrameProto.StartGame.userpid)
}

// uint32 seed = 3;
inline void StartGame::clear_seed() {
  seed_ = 0u;
}
inline uint32_t StartGame::_internal_seed() const {
  return seed_;
}
inline uint32_t StartGame::seed() const {
  // @@protoc_insertion_point(field_get:FrameProto.StartGame.seed)
  return _internal_seed();
}
inline void StartGame::_internal_set_seed(uint32_t value) {
  
  seed_ = value;
}
inline void StartGame::set_seed(uint32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:FrameProto.StartGame.seed)
}

// -------------------------------------------------------------------

// EndGame

// int32 roomid = 1;
inline void EndGame::clear_roomid() {
  roomid_ = 0;
}
inline int32_t EndGame::_internal_roomid() const {
  return roomid_;
}
inline int32_t EndGame::roomid() const {
  // @@protoc_insertion_point(field_get:FrameProto.EndGame.roomid)
  return _internal_roomid();
}
inline void EndGame::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void EndGame::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:FrameProto.EndGame.roomid)
}

// -------------------------------------------------------------------

// UserOperate

// repeated int64 data = 1;
inline int UserOperate::_internal_data_size() const {
  return data_.size();
}
inline int UserOperate::data_size() const {
  return _internal_data_size();
}
inline void UserOperate::clear_data() {
  data_.Clear();
}
inline int64_t UserOperate::_internal_data(int index) const {
  return data_.Get(index);
}
inline int64_t UserOperate::data(int index) const {
  // @@protoc_insertion_point(field_get:FrameProto.UserOperate.data)
  return _internal_data(index);
}
inline void UserOperate::set_data(int index, int64_t value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:FrameProto.UserOperate.data)
}
inline void UserOperate::_internal_add_data(int64_t value) {
  data_.Add(value);
}
inline void UserOperate::add_data(int64_t value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:FrameProto.UserOperate.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
UserOperate::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
UserOperate::data() const {
  // @@protoc_insertion_point(field_list:FrameProto.UserOperate.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
UserOperate::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
UserOperate::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:FrameProto.UserOperate.data)
  return _internal_mutable_data();
}

// .FrameProto.OperateType opt = 2;
inline void UserOperate::clear_opt() {
  opt_ = 0;
}
inline ::FrameProto::OperateType UserOperate::_internal_opt() const {
  return static_cast< ::FrameProto::OperateType >(opt_);
}
inline ::FrameProto::OperateType UserOperate::opt() const {
  // @@protoc_insertion_point(field_get:FrameProto.UserOperate.opt)
  return _internal_opt();
}
inline void UserOperate::_internal_set_opt(::FrameProto::OperateType value) {
  
  opt_ = value;
}
inline void UserOperate::set_opt(::FrameProto::OperateType value) {
  _internal_set_opt(value);
  // @@protoc_insertion_point(field_set:FrameProto.UserOperate.opt)
}

// int32 userpid = 3;
inline void UserOperate::clear_userpid() {
  userpid_ = 0;
}
inline int32_t UserOperate::_internal_userpid() const {
  return userpid_;
}
inline int32_t UserOperate::userpid() const {
  // @@protoc_insertion_point(field_get:FrameProto.UserOperate.userpid)
  return _internal_userpid();
}
inline void UserOperate::_internal_set_userpid(int32_t value) {
  
  userpid_ = value;
}
inline void UserOperate::set_userpid(int32_t value) {
  _internal_set_userpid(value);
  // @@protoc_insertion_point(field_set:FrameProto.UserOperate.userpid)
}

// -------------------------------------------------------------------

// Reconnect

// int32 roomid = 1;
inline void Reconnect::clear_roomid() {
  roomid_ = 0;
}
inline int32_t Reconnect::_internal_roomid() const {
  return roomid_;
}
inline int32_t Reconnect::roomid() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.roomid)
  return _internal_roomid();
}
inline void Reconnect::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void Reconnect::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.roomid)
}

// int32 userpid = 2;
inline void Reconnect::clear_userpid() {
  userpid_ = 0;
}
inline int32_t Reconnect::_internal_userpid() const {
  return userpid_;
}
inline int32_t Reconnect::userpid() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.userpid)
  return _internal_userpid();
}
inline void Reconnect::_internal_set_userpid(int32_t value) {
  
  userpid_ = value;
}
inline void Reconnect::set_userpid(int32_t value) {
  _internal_set_userpid(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.userpid)
}

// bool is_roomhost = 3;
inline void Reconnect::clear_is_roomhost() {
  is_roomhost_ = false;
}
inline bool Reconnect::_internal_is_roomhost() const {
  return is_roomhost_;
}
inline bool Reconnect::is_roomhost() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.is_roomhost)
  return _internal_is_roomhost();
}
inline void Reconnect::_internal_set_is_roomhost(bool value) {
  
  is_roomhost_ = value;
}
inline void Reconnect::set_is_roomhost(bool value) {
  _internal_set_is_roomhost(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.is_roomhost)
}

// uint32 seed = 4;
inline void Reconnect::clear_seed() {
  seed_ = 0u;
}
inline uint32_t Reconnect::_internal_seed() const {
  return seed_;
}
inline uint32_t Reconnect::seed() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.seed)
  return _internal_seed();
}
inline void Reconnect::_internal_set_seed(uint32_t value) {
  
  seed_ = value;
}
inline void Reconnect::set_seed(uint32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.seed)
}

// int32 token = 5;
inline void Reconnect::clear_token() {
  token_ = 0;
}
inline int32_t Reconnect::_internal_token() const {
  return token_;
}
inline int32_t Reconnect::token() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.token)
  return _internal_token();
}
inline void Reconnect::_internal_set_token(int32_t value) {
  
  token_ = value;
}
inline void Reconnect::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.token)
}

// bool ret = 6;
inline void Reconnect::clear_ret() {
  ret_ = false;
}
inline bool Reconnect::_internal_ret() const {
  return ret_;
}
inline bool Reconnect::ret() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.ret)
  return _internal_ret();
}
inline void Reconnect::_internal_set_ret(bool value) {
  
  ret_ = value;
}
inline void Reconnect::set_ret(bool value) {
  _internal_set_ret(value);
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.ret)
}

// string msg = 7;
inline void Reconnect::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& Reconnect::msg() const {
  // @@protoc_insertion_point(field_get:FrameProto.Reconnect.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reconnect::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FrameProto.Reconnect.msg)
}
inline std::string* Reconnect::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:FrameProto.Reconnect.msg)
  return _s;
}
inline const std::string& Reconnect::_internal_msg() const {
  return msg_.Get();
}
inline void Reconnect::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Reconnect::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Reconnect::release_msg() {
  // @@protoc_insertion_point(field_release:FrameProto.Reconnect.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Reconnect::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FrameProto.Reconnect.msg)
}

// -------------------------------------------------------------------

// Frame

// int32 frame_id = 1;
inline void Frame::clear_frame_id() {
  frame_id_ = 0;
}
inline int32_t Frame::_internal_frame_id() const {
  return frame_id_;
}
inline int32_t Frame::frame_id() const {
  // @@protoc_insertion_point(field_get:FrameProto.Frame.frame_id)
  return _internal_frame_id();
}
inline void Frame::_internal_set_frame_id(int32_t value) {
  
  frame_id_ = value;
}
inline void Frame::set_frame_id(int32_t value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:FrameProto.Frame.frame_id)
}

// repeated .FrameProto.UserOperate operates = 2;
inline int Frame::_internal_operates_size() const {
  return operates_.size();
}
inline int Frame::operates_size() const {
  return _internal_operates_size();
}
inline void Frame::clear_operates() {
  operates_.Clear();
}
inline ::FrameProto::UserOperate* Frame::mutable_operates(int index) {
  // @@protoc_insertion_point(field_mutable:FrameProto.Frame.operates)
  return operates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::UserOperate >*
Frame::mutable_operates() {
  // @@protoc_insertion_point(field_mutable_list:FrameProto.Frame.operates)
  return &operates_;
}
inline const ::FrameProto::UserOperate& Frame::_internal_operates(int index) const {
  return operates_.Get(index);
}
inline const ::FrameProto::UserOperate& Frame::operates(int index) const {
  // @@protoc_insertion_point(field_get:FrameProto.Frame.operates)
  return _internal_operates(index);
}
inline ::FrameProto::UserOperate* Frame::_internal_add_operates() {
  return operates_.Add();
}
inline ::FrameProto::UserOperate* Frame::add_operates() {
  ::FrameProto::UserOperate* _add = _internal_add_operates();
  // @@protoc_insertion_point(field_add:FrameProto.Frame.operates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::UserOperate >&
Frame::operates() const {
  // @@protoc_insertion_point(field_list:FrameProto.Frame.operates)
  return operates_;
}

// -------------------------------------------------------------------

// ChaseFrame

// -------------------------------------------------------------------

// GameReplay

// repeated .FrameProto.Frame frames = 1;
inline int GameReplay::_internal_frames_size() const {
  return frames_.size();
}
inline int GameReplay::frames_size() const {
  return _internal_frames_size();
}
inline void GameReplay::clear_frames() {
  frames_.Clear();
}
inline ::FrameProto::Frame* GameReplay::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:FrameProto.GameReplay.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::Frame >*
GameReplay::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:FrameProto.GameReplay.frames)
  return &frames_;
}
inline const ::FrameProto::Frame& GameReplay::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::FrameProto::Frame& GameReplay::frames(int index) const {
  // @@protoc_insertion_point(field_get:FrameProto.GameReplay.frames)
  return _internal_frames(index);
}
inline ::FrameProto::Frame* GameReplay::_internal_add_frames() {
  return frames_.Add();
}
inline ::FrameProto::Frame* GameReplay::add_frames() {
  ::FrameProto::Frame* _add = _internal_add_frames();
  // @@protoc_insertion_point(field_add:FrameProto.GameReplay.frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FrameProto::Frame >&
GameReplay::frames() const {
  // @@protoc_insertion_point(field_list:FrameProto.GameReplay.frames)
  return frames_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace FrameProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::FrameProto::OperateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FrameProto::OperateType>() {
  return ::FrameProto::OperateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Frame_2eproto
